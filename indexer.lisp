(in-package :com.search)

(defparameter *test-triples* nil)

(defstruct (mem (:type vector)) 
  (index-file-path #'(lambda (filename data-folder) (s+ data-folder "index/" filename)))
  (dict-size 0)
  (num-rec 0)
  (total (* 20 1024 1024))
  (block-size (* 64 1024))
  (num-of-triples 0)
  (triples '())
  (run 0)
  (termid 0)
  (dict (make-hash-table :test 'equal :size 1500000))
  (run-table (make-hash-table)))

(defun setup-triples (x)
  (setf *test-triples*
	(sort (map1-n #'(lambda (n) (list (random n) (random n) (random 10))) x)
	      #'triple-sorter)))

(defun triple-sorter (t1 t2)
  (or (< (triple-termid t1) (triple-termid t2))
      (and (= (triple-termid t1) (triple-termid t2))
	   (< (triple-docid t1) (triple-docid t2)))))

(defun estimates (mem)
  (list 'block-size (* 50 1024) 'can 'hold (truncate (/ (* 64 1024) (/ 324118 100000))) 'triples
	'numrec0 (truncate (/ (- mem (* 15 000000)) 12))
	'numrec1 (truncate (/ (- mem (* 15 100000)) 12))
	'numrec5 (truncate (/ (- mem (* 15 500000)) 12))
	'numrec10 (truncate (/ (- mem (* 15 1000000)) 12))
	'numrec20 (truncate (/ (- mem (* 15 2000000)) 12))
	'numrec50 (truncate (/ (- mem (* 15 5000000)) 12))))

(defun gaps (triples)
  (mapcar #'(lambda (t1 t2)
	       (let* ((tgap (- (triple-termid t2) (triple-termid t1)))
		      (dgap (if (zerop tgap)
				(- (triple-docid t2) (triple-docid t1))
				(triple-docid t2))))
		 (list tgap dgap (triple-pos t2))))
       (butlast (cons (make-triple :termid 0 :docid 0 :pos 0) triples)) triples))

(defun encode-triple-gap (triple-gap scheme)
  (let ((code (append
	       (funcall (symbol-function (second scheme)) (first triple-gap))
	       (funcall (symbol-function (third scheme)) (second triple-gap))
	       (funcall (symbol-function (fourth scheme)) (third triple-gap)))))
    (if (eq 'bits (first scheme))
	(bits->bytes code)
	code)))

;;mws inverter :algorithm
;;   Write 

(defstruct (triple (:type vector)) (termid 0) (docid 0) (pos 0) (run 0))
(defstruct (run (:type vector)) i (cur-pos -1) start end (bits nil) 
	   (triple (make-triple :termid 0 :docid 0 :pos 0 :run 0)) (loaded-block-num -1))

(defstruct (bits (:type vector)) len cur data)

(defun make-file-indexer (data-folder index-name filename)
  (make-indexer data-folder index-name :filename filename))

(defun make-general-indexer (data-folder index-name doc-reader doc-parser)
  (make-indexer data-folder index-name :doc-reader doc-reader :parse-document doc-parser))

(defun make-indexer (data-folder
		     index-name
		     &key 
		     (restart-p t)
		     (mem (make-mem))
		     (filename nil)
		     (doc-reader (checkpoint-file-reader filename :restart-p restart-p))
		     (parse-document #'word-tokenizer)
		     (encoding-scheme '(bytes encode-variable-bytes encode-variable-bytes encode-variable-bytes))
		     (mem-indexer #'in-memory-index)
		     (padd-byte 0))
  (labels ((mempath (filename)
	     (funcall (mem-index-file-path mem) filename data-folder))
	   (index-path->file (file)
	     (s+ data-folder "index/" index-name "/" file))
	   (create-lexicon ()
	     (write-hashtable (mempath "terms") (mem-dict mem)))
	   (write-run-table ()
	     (write-hashtable (mempath "runs") (mem-run-table mem)))
	   (merge-runs (&key (encoding-fn #'encode-variable-bytes))
	     (let ((heap (create-heap #'triple-sorter))
		   (lex (make-hash-table :size 1500000))
		   (records '())
		   (start 0)
		   (end 0)
		   (num-records 0)
		   (last (make-triple :termid 1))
		   (init '(0 . 0))
		   (total 0))
	       (labels ((write-record (index)
			  (when records
			    (let* ((other (or (first records)
					      '(0 . 0)))
				   (r (mapcan #'(lambda (gap) (append (funcall encoding-fn (car gap))
								      (funcall encoding-fn (cdr gap))))
					      (map-adj #'(lambda (x y) (cons (- (car y) (car x)) (cdr y)))
						       #'first
						       #'second
						       #'cdr
						       (cons init
							     (nreverse records)))))
				   (len (length r)))
			      (incf total len)
			      (write-sequence r index)
			      (setf (gethash (triple-termid last) lex)
				    (cons start (incf end len)))
			      (setf init other)))
			  (setf records nil)))
		 (print 'merging)
		 (dotimes (run (mem-run mem))
		   (when-bind (it (next-triple (1+ run) mem))
		     (heap-insert heap it)))
		 (with-open-file (index (mempath "index") 
					:direction :output 
					:element-type 'unsigned-byte 
					:if-exists :supersede 
					:if-does-not-exist :create)
		   (while (not (heap-empty-p heap))
		     (let ((next (heap-remove heap)))
		       (when (/= (triple-termid last) (triple-termid next))
			 (write-record index)
			 (setf init '(0 . 0))
			 (setf last (make-triple))
			 (setf start end))
		       (push (cons (triple-docid next) (triple-pos next)) records)
		       (incf num-records)
		       (setf last next)
		       (aif (next-triple (triple-run next) mem)
			    (if (and (typep it 'simple-vector) (not (zerop (triple-termid it))) (not (zerop (triple-docid it))))
				(heap-insert heap it)
				(print 'none-found))
			    (print 'none-found)))
		     (when (> (* 4 num-records) (mem-block-size mem)) (write-record index)))
		   (when records (write-record index)))
		 (print 'done)
		 (let ((terms (read-hashtable (mempath "terms"))))
		   (maphash #'(lambda (term termid)
				(setf (gethash term terms) (gethash termid lex)))
			    terms)
		   (write-hashtable (mempath "lexicon") terms)))))
	   (describe-index ()
	     (with-open-file (des (mempath "describe") :direction :output :if-exists :supersede :if-does-not-exist :create)
	       (write (list (cons 'name index-name)
			    (cons 'tokenizer (multiple-value-bind (a b c)
						 (function-lambda-expression parse-document)
					       (declare (ignore a b))
					       c))
			    (cons 'encoding-scheme encoding-scheme)
			    (cons 'padd-byte padd-byte)
			    (cons 'filename filename)
			    (cons 'block-size (mem-block-size mem))
			    (cons 'run-table (hash-table->alist (mem-run-table mem)))
			    (cons 'run (mem-run mem))) 
		      :stream des)))
	   (flush-in-memory-index->disk ()
	     (with-open-file (temp (mempath "temp")
				   :direction :output :element-type 'unsigned-byte 
				   :if-exists :append :if-does-not-exist :create)
	       (let* ((bytes (encode-gaps->bytes (gaps (sort (mem-triples mem) #'triple-sorter)) encoding-scheme))
		      (num-bytes (length bytes))
		      (file-length (file-length temp)))
		 (print 'flushing)
		 (vet-bytes bytes)
		 (file-position temp file-length)
		 (write-sequence bytes temp)
		 (unless (zerop (mod num-bytes (mem-block-size mem)))
		   (write-sequence (map1-n #'(lambda (x) (declare (ignore x)) padd-byte) 
					   (- (mem-block-size mem) (mod num-bytes (mem-block-size mem)))) temp))
		 (incf (mem-run mem))
		 (setf (gethash (mem-run mem) (mem-run-table mem))
		       (make-run :i (mem-run mem)
				 :start file-length 
				 :end (incf file-length 
					    (+ num-bytes 
					       (if (zerop (mod num-bytes (mem-block-size mem)))
						   0
						   (- (mem-block-size mem) (mod num-bytes (mem-block-size mem))))))))
		 (setf (mem-triples mem) nil)
		 (setf (mem-num-of-triples mem) 0)
		 (when (> (* (mem-block-size mem) (1+ (mem-run mem))) (mem-total mem))
		   (setf (mem-block-size mem) (/ (mem-block-size mem) 2))))))
	   (read-next-byte (run-num)
	     (let ((run (gethash run-num (mem-run-table mem))))
	       (if (block-loaded-p run mem)
		   (aref (run-bits run) (incf (run-cur-pos run)))
		   (if (nothing-to-read? run mem)
		       nil
		       (let ((seq (make-array (mem-block-size mem) :element-type 'unsigned-byte :fill-pointer t)))
			 (with-open-file (temp (mempath "temp") :direction :input :element-type 'unsigned-byte)
			   (print (list 'reading run-num (1+ (run-loaded-block-num run) )
					(run-start run) (run-end run) (/ (- (run-end run) (run-start run)) (mem-block-size mem))
					(+ (run-start run) (* (1+ (run-loaded-block-num run)) (mem-block-size mem)))))
			   (file-position temp (+ (run-start run) (* (incf (run-loaded-block-num run)) (mem-block-size mem))))
			   (setf (fill-pointer seq) (read-sequence seq temp))
			   (setf (run-cur-pos run) -1)
			   (setf (run-bits run) seq))
			 (read-next-byte run-num))))))
	   (read-variable-bytes (run-num)
	     (let ((byte 0)
		   (prv '()))
	       (loop
		  (setf byte (read-next-byte run-num))
		  (if (not byte)
		      (return nil)
		      (if (ends-in-0 byte)
			  (return (decode-variable-bytes (nreverse (cons byte prv))))
			  (push byte prv))))))
	   (multiway-in-place-sort-inverter ()
	     (let ((docid 0) (doc ""))
	       (setf (mem-index-file-path mem) #'(lambda (filename data-folder) (s+ data-folder "index/" index-name "/" filename)))
	       (ensure-directories-exist (mempath ""))
	       (when (probe-file (mempath "temp")) (delete-file (mempath "temp")))
	       (print 'init)
	       (loop
		  (setf doc (funcall doc-reader))
		  (when (or (not doc) (and (stringp doc) (string= doc "")))
		    (flush-in-memory-index->disk)
		    (memory-status mem)
		    (return 'done))
		  (progn
		    (print (cons 'indexing (incf docid)))
		    (funcall mem-indexer docid (terms->id (funcall parse-document doc) mem) mem)
		    (update-mem-parameters mem)
		    (when (memory-limit-reached? mem)
		      (flush-in-memory-index->disk)
		      (memory-status mem))))
	       (print 'writing-run-table)
	       (write-run-table)
	       (print 'index-details)
	       (describe-index)
	       (print 'creating-lexicon)
	       (create-lexicon)
	       (print 'merging-runs)
	       (merge-runs))))
    #'(lambda (dispatch) 
	(let ((lexicon (read-hashtable (index-path->file "lexicon"))))
	  (case dispatch
	    (:index (multiway-in-place-sort-inverter))
	    (:searcher (let ((term dispatch))
			  (awhen (gethash (string-upcase term) lexicon)
			    (delete-duplicates 
			     (let ((docid 0))
			       (map-adj #'(lambda (x y) (declare (ignore x)) (cons (incf docid (car y)) (cdr y)))
					#'(lambda (list) (cons (first list) (second list)))
					#'(lambda (list) (cons (third list) (fourth list)))
					#'cddr
					(append '(0 0)
						(read-all-variable-bytes 
						 (read-bytes 
						  (index-path->file "index")
						  (car it) 
						  (cdr it))))))
			     :test #'= :key #'car))))
	    (:lexicon #'(lambda (term)
			  (gethash (string-upcase term) lexicon))))))))

(defun terms->id (terms mem)
  (mapcar #'(lambda (bits)
	      (cons (or (gethash (car bits) (mem-dict mem))
			(setf (gethash (car bits) (mem-dict mem)) (incf (mem-termid mem))))
		    (cdr bits)))
	  terms))

(defun encode-gaps->bytes (gaps encoding-scheme)
  (mappend #'(lambda (gap) (encode-triple-gap gap encoding-scheme)) gaps))

(defun memory-limit-reached? (mem)
  (>= (mem-num-of-triples mem) (mem-num-rec mem)))

(defun in-memory-index (docid termids mem)
  (dolist (termid termids)
    (push (make-triple :termid (car termid) :docid docid :pos (cdr termid)) (mem-triples mem))
    (incf (mem-num-of-triples mem))))

(defun update-mem-parameters (mem)
  (progn
    (setf (mem-dict-size mem) (hash-table-count (mem-dict mem)))
    (setf (mem-num-rec mem) (numrec mem))))

(defun vet-bytes (bytes)
  (print (list 'unsound (remove-if #'(lambda (byte) (and (> byte -1) (< byte 256))) bytes))))

(defun numrec (mem)
  (let ((num (truncate (/ (- (mem-total mem) (* 15 (mem-dict-size mem))) 12))))
    (if (or (> 0 num) (> num 500000))
	500000
	num)))

(defun term-group-indexer (docid termids mem)
  (declare (ignore docid))
  (dolist (term-set (permutations termids))
    (push (make-triple :termid (car (first term-set)) :docid (car (second term-set)) :pos (cdr (second term-set))) 
	  (mem-triples mem))
    (incf (mem-num-of-triples mem))))

(defun memory-status (mem)
  (print (list 'total (mem-total mem)
	       'dictsize (mem-dict-size mem)
	       'numrecs (mem-num-rec mem)
	       'blocksize (mem-block-size mem)
	       'num-of-triples (mem-num-of-triples mem)
	       'run (mem-run mem)
	       'max-termid (mem-termid mem)
	       'runs (hash-table->alist (mem-run-table mem)))))

(defun block-loaded-p (run mem)
  (and (run-bits run)
       (> (mem-block-size mem) (1+ (run-cur-pos run)))))

(defun ends-in-0 (byte)
  (zerop (car (last (convert-integer-to-bit-string byte)))))

(defun nothing-to-read? (run mem)
  (>= (* (run-loaded-block-num run) (mem-block-size mem)) (- (run-end run) (run-start run))))

(defun next-triple (run-num mem)
  (let ((run (gethash run-num (mem-run-table mem)))
	(next-tgap (read-variable-bytes run-num mem))
	(next-dgap (read-variable-bytes run-num mem))
	(next-pos  (read-variable-bytes run-num mem)))
    (setf (run-triple run) 
	  (if (and next-tgap next-dgap next-pos
		   (not (and (zerop next-tgap) (zerop next-dgap) (zerop next-pos)))) ;is it the padding
	      (make-triple :termid (+ (triple-termid (run-triple run)) next-tgap)
			   :docid (if (zerop next-tgap)
				      (+ (triple-docid (run-triple run)) next-dgap)
				      next-dgap)
			   :pos next-pos
			   :run run-num)
	      nil))))
    
(defun read-all-variable-bytes (bytes)
  (let ((cur-pos -1)
	(results '())
	(length (length bytes)))
    (while (> length (1+ cur-pos))
      (multiple-value-bind (integer cur)
	  (read-variable-bytes<-bits bytes cur-pos)
	(setf cur-pos cur)
	(push integer results)))
    (nreverse results)))

(defun read-variable-bytes<-bits (bytes cur-pos)
  (let ((byte 0)
	(prv '()))
    (loop
       (setf byte (aref bytes (incf cur-pos)))
       (if (not bytes)
	   (return nil)
	   (if (ends-in-0 byte)
	       (return (values (decode-variable-bytes (nreverse (cons byte prv))) cur-pos))
	       (push byte prv))))))

(defun read-bytes (filename start end)
  (with-open-file (index filename :element-type 'unsigned-byte)
    (let ((seq (make-array (- end start) :element-type 'unsigned-byte :fill-pointer t)))
      (file-position index start)
      (setf (fill-pointer seq) (read-sequence seq index))
      seq)))
